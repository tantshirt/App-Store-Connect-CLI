package winbackoffers

import (
	"context"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/peterbourgon/ff/v3/ffcli"

	"github.com/rudrankriyam/App-Store-Connect-CLI/internal/asc"
)

const winBackOffersMaxLimit = 200

var winBackOfferDurationValues = []string{
	string(asc.SubscriptionOfferDurationThreeDays),
	string(asc.SubscriptionOfferDurationOneWeek),
	string(asc.SubscriptionOfferDurationTwoWeeks),
	string(asc.SubscriptionOfferDurationOneMonth),
	string(asc.SubscriptionOfferDurationTwoMonths),
	string(asc.SubscriptionOfferDurationThreeMonths),
	string(asc.SubscriptionOfferDurationSixMonths),
	string(asc.SubscriptionOfferDurationOneYear),
}

var winBackOfferDurationMap = map[string]asc.SubscriptionOfferDuration{
	string(asc.SubscriptionOfferDurationThreeDays):   asc.SubscriptionOfferDurationThreeDays,
	string(asc.SubscriptionOfferDurationOneWeek):     asc.SubscriptionOfferDurationOneWeek,
	string(asc.SubscriptionOfferDurationTwoWeeks):    asc.SubscriptionOfferDurationTwoWeeks,
	string(asc.SubscriptionOfferDurationOneMonth):    asc.SubscriptionOfferDurationOneMonth,
	string(asc.SubscriptionOfferDurationTwoMonths):   asc.SubscriptionOfferDurationTwoMonths,
	string(asc.SubscriptionOfferDurationThreeMonths): asc.SubscriptionOfferDurationThreeMonths,
	string(asc.SubscriptionOfferDurationSixMonths):   asc.SubscriptionOfferDurationSixMonths,
	string(asc.SubscriptionOfferDurationOneYear):     asc.SubscriptionOfferDurationOneYear,
}

var winBackOfferModeValues = []string{
	string(asc.SubscriptionOfferModePayAsYouGo),
	string(asc.SubscriptionOfferModePayUpFront),
	string(asc.SubscriptionOfferModeFreeTrial),
}

var winBackOfferModeMap = map[string]asc.SubscriptionOfferMode{
	string(asc.SubscriptionOfferModePayAsYouGo): asc.SubscriptionOfferModePayAsYouGo,
	string(asc.SubscriptionOfferModePayUpFront): asc.SubscriptionOfferModePayUpFront,
	string(asc.SubscriptionOfferModeFreeTrial):  asc.SubscriptionOfferModeFreeTrial,
}

var winBackOfferPriorityValues = []string{
	string(asc.WinBackOfferPriorityHigh),
	string(asc.WinBackOfferPriorityNormal),
}

var winBackOfferPriorityMap = map[string]asc.WinBackOfferPriority{
	string(asc.WinBackOfferPriorityHigh):   asc.WinBackOfferPriorityHigh,
	string(asc.WinBackOfferPriorityNormal): asc.WinBackOfferPriorityNormal,
}

var winBackOfferPromotionIntentValues = []string{
	string(asc.WinBackOfferPromotionNotPromoted),
	string(asc.WinBackOfferPromotionUseAutoGeneratedAssets),
}

var winBackOfferPromotionIntentMap = map[string]asc.WinBackOfferPromotionIntent{
	string(asc.WinBackOfferPromotionNotPromoted):            asc.WinBackOfferPromotionNotPromoted,
	string(asc.WinBackOfferPromotionUseAutoGeneratedAssets): asc.WinBackOfferPromotionUseAutoGeneratedAssets,
}

// WinBackOffersCommand returns the win-back offers command group.
func WinBackOffersCommand() *ffcli.Command {
	fs := flag.NewFlagSet("win-back-offers", flag.ExitOnError)

	return &ffcli.Command{
		Name:       "win-back-offers",
		ShortUsage: "asc win-back-offers <subcommand> [flags]",
		ShortHelp:  "Manage win-back offers for subscriptions.",
		LongHelp: `Manage win-back offers for subscriptions.

Examples:
  asc win-back-offers list --subscription "SUB_ID"
  asc win-back-offers get --id "OFFER_ID"
  asc win-back-offers create --subscription "SUB_ID" --reference-name "spring-2026" --offer-id "OFFER-1" --duration ONE_MONTH --offer-mode PAY_AS_YOU_GO --period-count 1 --eligibility-paid-months 6 --eligibility-last-subscribed-min 3 --eligibility-last-subscribed-max 12 --start-date "2026-02-01" --priority HIGH --price "PRICE_ID"
  asc win-back-offers update --id "OFFER_ID" --priority NORMAL
  asc win-back-offers prices --id "OFFER_ID"`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Subcommands: []*ffcli.Command{
			WinBackOffersListCommand(),
			WinBackOffersGetCommand(),
			WinBackOffersCreateCommand(),
			WinBackOffersUpdateCommand(),
			WinBackOffersDeleteCommand(),
			WinBackOffersPricesCommand(),
			WinBackOffersPricesRelationshipsCommand(),
			WinBackOffersRelationshipsCommand(),
		},
		Exec: func(ctx context.Context, args []string) error {
			return flag.ErrHelp
		},
	}
}

// WinBackOffersListCommand returns the win-back offers list subcommand.
func WinBackOffersListCommand() *ffcli.Command {
	fs := flag.NewFlagSet("list", flag.ExitOnError)

	subscriptionID := fs.String("subscription", "", "Subscription ID")
	limit := fs.Int("limit", 0, "Maximum results per page (1-200)")
	next := fs.String("next", "", "Fetch next page using a links.next URL")
	paginate := fs.Bool("paginate", false, "Automatically fetch all pages (aggregate results)")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "list",
		ShortUsage: "asc win-back-offers list [flags]",
		ShortHelp:  "List win-back offers for a subscription.",
		LongHelp: `List win-back offers for a subscription.

Examples:
  asc win-back-offers list --subscription "SUB_ID"
  asc win-back-offers list --subscription "SUB_ID" --limit 50
  asc win-back-offers list --subscription "SUB_ID" --paginate`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			if *limit != 0 && (*limit < 1 || *limit > winBackOffersMaxLimit) {
				return fmt.Errorf("win-back-offers list: --limit must be between 1 and %d", winBackOffersMaxLimit)
			}
			if err := validateNextURL(*next); err != nil {
				return fmt.Errorf("win-back-offers list: %w", err)
			}

			id := strings.TrimSpace(*subscriptionID)
			if id == "" && strings.TrimSpace(*next) == "" {
				fmt.Fprintln(os.Stderr, "Error: --subscription is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers list: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			opts := []asc.WinBackOffersOption{
				asc.WithWinBackOffersLimit(*limit),
				asc.WithWinBackOffersNextURL(*next),
			}

			if *paginate {
				paginateOpts := append(opts, asc.WithWinBackOffersLimit(winBackOffersMaxLimit))
				firstPage, err := client.GetSubscriptionWinBackOffers(requestCtx, id, paginateOpts...)
				if err != nil {
					return fmt.Errorf("win-back-offers list: failed to fetch: %w", err)
				}

				resp, err := asc.PaginateAll(requestCtx, firstPage, func(ctx context.Context, nextURL string) (asc.PaginatedResponse, error) {
					return client.GetSubscriptionWinBackOffers(ctx, id, asc.WithWinBackOffersNextURL(nextURL))
				})
				if err != nil {
					return fmt.Errorf("win-back-offers list: %w", err)
				}

				return printOutput(resp, *output, *pretty)
			}

			resp, err := client.GetSubscriptionWinBackOffers(requestCtx, id, opts...)
			if err != nil {
				return fmt.Errorf("win-back-offers list: failed to fetch: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersGetCommand returns the win-back offers get subcommand.
func WinBackOffersGetCommand() *ffcli.Command {
	fs := flag.NewFlagSet("get", flag.ExitOnError)

	id := fs.String("id", "", "Win-back offer ID")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "get",
		ShortUsage: "asc win-back-offers get --id OFFER_ID",
		ShortHelp:  "Get a win-back offer by ID.",
		LongHelp: `Get a win-back offer by ID.

Examples:
  asc win-back-offers get --id "OFFER_ID"`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			trimmedID := strings.TrimSpace(*id)
			if trimmedID == "" {
				fmt.Fprintln(os.Stderr, "Error: --id is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers get: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			resp, err := client.GetWinBackOffer(requestCtx, trimmedID)
			if err != nil {
				return fmt.Errorf("win-back-offers get: failed to fetch: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersCreateCommand returns the win-back offers create subcommand.
func WinBackOffersCreateCommand() *ffcli.Command {
	fs := flag.NewFlagSet("create", flag.ExitOnError)

	subscriptionID := fs.String("subscription", "", "Subscription ID")
	referenceName := fs.String("reference-name", "", "Reference name")
	offerID := fs.String("offer-id", "", "Offer ID")
	duration := fs.String("duration", "", "Offer duration: "+strings.Join(winBackOfferDurationValues, ", "))
	offerMode := fs.String("offer-mode", "", "Offer mode: "+strings.Join(winBackOfferModeValues, ", "))
	var periodCount optionalInt
	fs.Var(&periodCount, "period-count", "Number of periods (required)")
	var eligibilityPaidMonths optionalInt
	fs.Var(&eligibilityPaidMonths, "eligibility-paid-months", "Paid subscription duration in months (required)")
	var eligibilityLastSubscribedMin optionalInt
	fs.Var(&eligibilityLastSubscribedMin, "eligibility-last-subscribed-min", "Minimum months since last subscribed (required)")
	var eligibilityLastSubscribedMax optionalInt
	fs.Var(&eligibilityLastSubscribedMax, "eligibility-last-subscribed-max", "Maximum months since last subscribed (required)")
	var eligibilityWaitMonths optionalInt
	fs.Var(&eligibilityWaitMonths, "eligibility-wait-months", "Wait between offers in months (optional)")
	startDate := fs.String("start-date", "", "Start date (YYYY-MM-DD)")
	endDate := fs.String("end-date", "", "End date (YYYY-MM-DD)")
	priority := fs.String("priority", "", "Offer priority: "+strings.Join(winBackOfferPriorityValues, ", "))
	promotionIntent := fs.String("promotion-intent", "", "Promotion intent: "+strings.Join(winBackOfferPromotionIntentValues, ", "))
	priceIDs := fs.String("price", "", "Win-back offer price ID(s), comma-separated")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "create",
		ShortUsage: "asc win-back-offers create [flags]",
		ShortHelp:  "Create a win-back offer.",
		LongHelp: `Create a win-back offer.

Examples:
  asc win-back-offers create --subscription "SUB_ID" --reference-name "spring-2026" --offer-id "OFFER-1" --duration ONE_MONTH --offer-mode PAY_AS_YOU_GO --period-count 1 --eligibility-paid-months 6 --eligibility-last-subscribed-min 3 --eligibility-last-subscribed-max 12 --start-date "2026-02-01" --priority HIGH --price "PRICE_ID"`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			subscription := strings.TrimSpace(*subscriptionID)
			if subscription == "" {
				fmt.Fprintln(os.Stderr, "Error: --subscription is required")
				return flag.ErrHelp
			}

			name := strings.TrimSpace(*referenceName)
			if name == "" {
				fmt.Fprintln(os.Stderr, "Error: --reference-name is required")
				return flag.ErrHelp
			}

			offer := strings.TrimSpace(*offerID)
			if offer == "" {
				fmt.Fprintln(os.Stderr, "Error: --offer-id is required")
				return flag.ErrHelp
			}

			if strings.TrimSpace(*duration) == "" {
				fmt.Fprintln(os.Stderr, "Error: --duration is required")
				return flag.ErrHelp
			}
			durationValue, err := normalizeWinBackOfferDuration(*duration)
			if err != nil {
				return fmt.Errorf("win-back-offers create: %w", err)
			}

			if strings.TrimSpace(*offerMode) == "" {
				fmt.Fprintln(os.Stderr, "Error: --offer-mode is required")
				return flag.ErrHelp
			}
			offerModeValue, err := normalizeWinBackOfferMode(*offerMode)
			if err != nil {
				return fmt.Errorf("win-back-offers create: %w", err)
			}

			if !periodCount.set {
				fmt.Fprintln(os.Stderr, "Error: --period-count is required")
				return flag.ErrHelp
			}
			if periodCount.value <= 0 {
				return fmt.Errorf("win-back-offers create: --period-count must be greater than 0")
			}

			if !eligibilityPaidMonths.set {
				fmt.Fprintln(os.Stderr, "Error: --eligibility-paid-months is required")
				return flag.ErrHelp
			}
			if eligibilityPaidMonths.value < 0 {
				return fmt.Errorf("win-back-offers create: --eligibility-paid-months must be 0 or greater")
			}

			if !eligibilityLastSubscribedMin.set {
				fmt.Fprintln(os.Stderr, "Error: --eligibility-last-subscribed-min is required")
				return flag.ErrHelp
			}
			if !eligibilityLastSubscribedMax.set {
				fmt.Fprintln(os.Stderr, "Error: --eligibility-last-subscribed-max is required")
				return flag.ErrHelp
			}
			if eligibilityLastSubscribedMin.value < 0 || eligibilityLastSubscribedMax.value < 0 {
				return fmt.Errorf("win-back-offers create: eligibility last subscribed values must be 0 or greater")
			}
			if eligibilityLastSubscribedMin.value > eligibilityLastSubscribedMax.value {
				return fmt.Errorf("win-back-offers create: eligibility last subscribed min must be less than or equal to max")
			}

			if strings.TrimSpace(*startDate) == "" {
				fmt.Fprintln(os.Stderr, "Error: --start-date is required")
				return flag.ErrHelp
			}
			normalizedStartDate, err := normalizeDate(*startDate, "--start-date")
			if err != nil {
				return fmt.Errorf("win-back-offers create: %w", err)
			}

			if strings.TrimSpace(*priority) == "" {
				fmt.Fprintln(os.Stderr, "Error: --priority is required")
				return flag.ErrHelp
			}
			priorityValue, err := normalizeWinBackOfferPriority(*priority)
			if err != nil {
				return fmt.Errorf("win-back-offers create: %w", err)
			}

			prices := parseCommaSeparatedIDs(*priceIDs)
			if len(prices) == 0 {
				fmt.Fprintln(os.Stderr, "Error: --price is required")
				return flag.ErrHelp
			}

			if eligibilityWaitMonths.set && eligibilityWaitMonths.value < 0 {
				return fmt.Errorf("win-back-offers create: --eligibility-wait-months must be 0 or greater")
			}

			normalizedEndDate := ""
			if strings.TrimSpace(*endDate) != "" {
				normalizedEndDate, err = normalizeDate(*endDate, "--end-date")
				if err != nil {
					return fmt.Errorf("win-back-offers create: %w", err)
				}
			}

			var promotionIntentValue *asc.WinBackOfferPromotionIntent
			if strings.TrimSpace(*promotionIntent) != "" {
				intent, err := normalizeWinBackOfferPromotionIntent(*promotionIntent)
				if err != nil {
					return fmt.Errorf("win-back-offers create: %w", err)
				}
				promotionIntentValue = &intent
			}

			priceData := make([]asc.ResourceData, 0, len(prices))
			for _, priceID := range prices {
				priceData = append(priceData, asc.ResourceData{
					Type: asc.ResourceTypeWinBackOfferPrices,
					ID:   priceID,
				})
			}

			var waitBetween *int
			if eligibilityWaitMonths.set {
				waitBetween = &eligibilityWaitMonths.value
			}

			var endDateValue *string
			if normalizedEndDate != "" {
				endDateValue = &normalizedEndDate
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers create: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			req := asc.WinBackOfferCreateRequest{
				Data: asc.WinBackOfferCreateData{
					Type: asc.ResourceTypeWinBackOffers,
					Attributes: asc.WinBackOfferCreateAttributes{
						ReferenceName: name,
						OfferID:       offer,
						Duration:      durationValue,
						OfferMode:     offerModeValue,
						PeriodCount:   periodCount.value,
						CustomerEligibilityPaidSubscriptionDurationInMonths: eligibilityPaidMonths.value,
						CustomerEligibilityTimeSinceLastSubscribedInMonths:  asc.NewIntegerRange(eligibilityLastSubscribedMin.value, eligibilityLastSubscribedMax.value),
						CustomerEligibilityWaitBetweenOffersInMonths:        waitBetween,
						StartDate:       normalizedStartDate,
						EndDate:         endDateValue,
						Priority:        priorityValue,
						PromotionIntent: promotionIntentValue,
					},
					Relationships: asc.WinBackOfferCreateRelationships{
						Subscription: asc.Relationship{
							Data: asc.ResourceData{
								Type: asc.ResourceTypeSubscriptions,
								ID:   subscription,
							},
						},
						Prices: asc.RelationshipList{Data: priceData},
					},
				},
			}

			resp, err := client.CreateWinBackOffer(requestCtx, req)
			if err != nil {
				return fmt.Errorf("win-back-offers create: failed to create: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersUpdateCommand returns the win-back offers update subcommand.
func WinBackOffersUpdateCommand() *ffcli.Command {
	fs := flag.NewFlagSet("update", flag.ExitOnError)

	id := fs.String("id", "", "Win-back offer ID")
	var eligibilityPaidMonths optionalInt
	fs.Var(&eligibilityPaidMonths, "eligibility-paid-months", "Paid subscription duration in months")
	var eligibilityLastSubscribedMin optionalInt
	fs.Var(&eligibilityLastSubscribedMin, "eligibility-last-subscribed-min", "Minimum months since last subscribed")
	var eligibilityLastSubscribedMax optionalInt
	fs.Var(&eligibilityLastSubscribedMax, "eligibility-last-subscribed-max", "Maximum months since last subscribed")
	var eligibilityWaitMonths optionalInt
	fs.Var(&eligibilityWaitMonths, "eligibility-wait-months", "Wait between offers in months")
	startDate := fs.String("start-date", "", "Start date (YYYY-MM-DD)")
	endDate := fs.String("end-date", "", "End date (YYYY-MM-DD)")
	priority := fs.String("priority", "", "Offer priority: "+strings.Join(winBackOfferPriorityValues, ", "))
	promotionIntent := fs.String("promotion-intent", "", "Promotion intent: "+strings.Join(winBackOfferPromotionIntentValues, ", "))
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "update",
		ShortUsage: "asc win-back-offers update [flags]",
		ShortHelp:  "Update a win-back offer.",
		LongHelp: `Update a win-back offer.

Examples:
  asc win-back-offers update --id "OFFER_ID" --priority NORMAL
  asc win-back-offers update --id "OFFER_ID" --end-date "2026-04-01"`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			trimmedID := strings.TrimSpace(*id)
			if trimmedID == "" {
				fmt.Fprintln(os.Stderr, "Error: --id is required")
				return flag.ErrHelp
			}

			hasUpdates := false
			attrs := asc.WinBackOfferUpdateAttributes{}

			if eligibilityPaidMonths.set {
				if eligibilityPaidMonths.value < 0 {
					return fmt.Errorf("win-back-offers update: --eligibility-paid-months must be 0 or greater")
				}
				attrs.CustomerEligibilityPaidSubscriptionDurationInMonths = &eligibilityPaidMonths.value
				hasUpdates = true
			}

			if eligibilityLastSubscribedMin.set || eligibilityLastSubscribedMax.set {
				if !eligibilityLastSubscribedMin.set || !eligibilityLastSubscribedMax.set {
					return fmt.Errorf("win-back-offers update: --eligibility-last-subscribed-min and --eligibility-last-subscribed-max must be set together")
				}
				if eligibilityLastSubscribedMin.value < 0 || eligibilityLastSubscribedMax.value < 0 {
					return fmt.Errorf("win-back-offers update: eligibility last subscribed values must be 0 or greater")
				}
				if eligibilityLastSubscribedMin.value > eligibilityLastSubscribedMax.value {
					return fmt.Errorf("win-back-offers update: eligibility last subscribed min must be less than or equal to max")
				}
				rangeValue := asc.NewIntegerRange(eligibilityLastSubscribedMin.value, eligibilityLastSubscribedMax.value)
				attrs.CustomerEligibilityTimeSinceLastSubscribedInMonths = &rangeValue
				hasUpdates = true
			}

			if eligibilityWaitMonths.set {
				if eligibilityWaitMonths.value < 0 {
					return fmt.Errorf("win-back-offers update: --eligibility-wait-months must be 0 or greater")
				}
				attrs.CustomerEligibilityWaitBetweenOffersInMonths = &eligibilityWaitMonths.value
				hasUpdates = true
			}

			if strings.TrimSpace(*startDate) != "" {
				normalized, err := normalizeDate(*startDate, "--start-date")
				if err != nil {
					return fmt.Errorf("win-back-offers update: %w", err)
				}
				attrs.StartDate = &normalized
				hasUpdates = true
			}

			if strings.TrimSpace(*endDate) != "" {
				normalized, err := normalizeDate(*endDate, "--end-date")
				if err != nil {
					return fmt.Errorf("win-back-offers update: %w", err)
				}
				attrs.EndDate = &normalized
				hasUpdates = true
			}

			if strings.TrimSpace(*priority) != "" {
				value, err := normalizeWinBackOfferPriority(*priority)
				if err != nil {
					return fmt.Errorf("win-back-offers update: %w", err)
				}
				attrs.Priority = &value
				hasUpdates = true
			}

			if strings.TrimSpace(*promotionIntent) != "" {
				value, err := normalizeWinBackOfferPromotionIntent(*promotionIntent)
				if err != nil {
					return fmt.Errorf("win-back-offers update: %w", err)
				}
				attrs.PromotionIntent = &value
				hasUpdates = true
			}

			if !hasUpdates {
				fmt.Fprintln(os.Stderr, "Error: at least one update flag is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers update: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			resp, err := client.UpdateWinBackOffer(requestCtx, trimmedID, attrs)
			if err != nil {
				return fmt.Errorf("win-back-offers update: failed to update: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersDeleteCommand returns the win-back offers delete subcommand.
func WinBackOffersDeleteCommand() *ffcli.Command {
	fs := flag.NewFlagSet("delete", flag.ExitOnError)

	id := fs.String("id", "", "Win-back offer ID")
	confirm := fs.Bool("confirm", false, "Confirm deletion")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "delete",
		ShortUsage: "asc win-back-offers delete --id OFFER_ID --confirm",
		ShortHelp:  "Delete a win-back offer.",
		LongHelp: `Delete a win-back offer.

Examples:
  asc win-back-offers delete --id "OFFER_ID" --confirm`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			trimmedID := strings.TrimSpace(*id)
			if trimmedID == "" {
				fmt.Fprintln(os.Stderr, "Error: --id is required")
				return flag.ErrHelp
			}
			if !*confirm {
				fmt.Fprintln(os.Stderr, "Error: --confirm is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers delete: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			if err := client.DeleteWinBackOffer(requestCtx, trimmedID); err != nil {
				return fmt.Errorf("win-back-offers delete: failed to delete: %w", err)
			}

			result := &asc.WinBackOfferDeleteResult{
				ID:      trimmedID,
				Deleted: true,
			}

			return printOutput(result, *output, *pretty)
		},
	}
}

// WinBackOffersPricesCommand returns the win-back offers prices subcommand.
func WinBackOffersPricesCommand() *ffcli.Command {
	fs := flag.NewFlagSet("prices", flag.ExitOnError)

	id := fs.String("id", "", "Win-back offer ID")
	limit := fs.Int("limit", 0, "Maximum results per page (1-200)")
	next := fs.String("next", "", "Fetch next page using a links.next URL")
	paginate := fs.Bool("paginate", false, "Automatically fetch all pages (aggregate results)")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "prices",
		ShortUsage: "asc win-back-offers prices --id OFFER_ID [flags]",
		ShortHelp:  "List prices for a win-back offer.",
		LongHelp: `List prices for a win-back offer.

Examples:
  asc win-back-offers prices --id "OFFER_ID"
  asc win-back-offers prices --id "OFFER_ID" --paginate`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			if *limit != 0 && (*limit < 1 || *limit > winBackOffersMaxLimit) {
				return fmt.Errorf("win-back-offers prices: --limit must be between 1 and %d", winBackOffersMaxLimit)
			}
			if err := validateNextURL(*next); err != nil {
				return fmt.Errorf("win-back-offers prices: %w", err)
			}

			trimmedID := strings.TrimSpace(*id)
			if trimmedID == "" && strings.TrimSpace(*next) == "" {
				fmt.Fprintln(os.Stderr, "Error: --id is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers prices: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			opts := []asc.WinBackOfferPricesOption{
				asc.WithWinBackOfferPricesLimit(*limit),
				asc.WithWinBackOfferPricesNextURL(*next),
			}

			if *paginate {
				paginateOpts := append(opts, asc.WithWinBackOfferPricesLimit(winBackOffersMaxLimit))
				firstPage, err := client.GetWinBackOfferPrices(requestCtx, trimmedID, paginateOpts...)
				if err != nil {
					return fmt.Errorf("win-back-offers prices: failed to fetch: %w", err)
				}

				resp, err := asc.PaginateAll(requestCtx, firstPage, func(ctx context.Context, nextURL string) (asc.PaginatedResponse, error) {
					return client.GetWinBackOfferPrices(ctx, trimmedID, asc.WithWinBackOfferPricesNextURL(nextURL))
				})
				if err != nil {
					return fmt.Errorf("win-back-offers prices: %w", err)
				}

				return printOutput(resp, *output, *pretty)
			}

			resp, err := client.GetWinBackOfferPrices(requestCtx, trimmedID, opts...)
			if err != nil {
				return fmt.Errorf("win-back-offers prices: failed to fetch: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersPricesRelationshipsCommand returns the price relationships subcommand.
func WinBackOffersPricesRelationshipsCommand() *ffcli.Command {
	fs := flag.NewFlagSet("prices-relationships", flag.ExitOnError)

	id := fs.String("id", "", "Win-back offer ID")
	limit := fs.Int("limit", 0, "Maximum results per page (1-200)")
	next := fs.String("next", "", "Fetch next page using a links.next URL")
	paginate := fs.Bool("paginate", false, "Automatically fetch all pages (aggregate results)")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "prices-relationships",
		ShortUsage: "asc win-back-offers prices-relationships --id OFFER_ID [flags]",
		ShortHelp:  "List price relationships for a win-back offer.",
		LongHelp: `List price relationships for a win-back offer.

Examples:
  asc win-back-offers prices-relationships --id "OFFER_ID"
  asc win-back-offers prices-relationships --id "OFFER_ID" --paginate`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			if *limit != 0 && (*limit < 1 || *limit > winBackOffersMaxLimit) {
				return fmt.Errorf("win-back-offers prices-relationships: --limit must be between 1 and %d", winBackOffersMaxLimit)
			}
			if err := validateNextURL(*next); err != nil {
				return fmt.Errorf("win-back-offers prices-relationships: %w", err)
			}

			trimmedID := strings.TrimSpace(*id)
			if trimmedID == "" && strings.TrimSpace(*next) == "" {
				fmt.Fprintln(os.Stderr, "Error: --id is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers prices-relationships: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			opts := []asc.LinkagesOption{
				asc.WithLinkagesLimit(*limit),
				asc.WithLinkagesNextURL(*next),
			}

			if *paginate {
				paginateOpts := append(opts, asc.WithLinkagesLimit(winBackOffersMaxLimit))
				firstPage, err := client.GetWinBackOfferPricesRelationships(requestCtx, trimmedID, paginateOpts...)
				if err != nil {
					return fmt.Errorf("win-back-offers prices-relationships: failed to fetch: %w", err)
				}

				resp, err := asc.PaginateAll(requestCtx, firstPage, func(ctx context.Context, nextURL string) (asc.PaginatedResponse, error) {
					return client.GetWinBackOfferPricesRelationships(ctx, trimmedID, asc.WithLinkagesNextURL(nextURL))
				})
				if err != nil {
					return fmt.Errorf("win-back-offers prices-relationships: %w", err)
				}

				return printOutput(resp, *output, *pretty)
			}

			resp, err := client.GetWinBackOfferPricesRelationships(requestCtx, trimmedID, opts...)
			if err != nil {
				return fmt.Errorf("win-back-offers prices-relationships: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

// WinBackOffersRelationshipsCommand returns the win-back offer relationships subcommand.
func WinBackOffersRelationshipsCommand() *ffcli.Command {
	fs := flag.NewFlagSet("relationships", flag.ExitOnError)

	subscriptionID := fs.String("subscription", "", "Subscription ID")
	limit := fs.Int("limit", 0, "Maximum results per page (1-200)")
	next := fs.String("next", "", "Fetch next page using a links.next URL")
	paginate := fs.Bool("paginate", false, "Automatically fetch all pages (aggregate results)")
	output := fs.String("output", "json", "Output format: json (default), table, markdown")
	pretty := fs.Bool("pretty", false, "Pretty-print JSON output")

	return &ffcli.Command{
		Name:       "relationships",
		ShortUsage: "asc win-back-offers relationships --subscription SUB_ID [flags]",
		ShortHelp:  "List win-back offer relationships for a subscription.",
		LongHelp: `List win-back offer relationships for a subscription.

Examples:
  asc win-back-offers relationships --subscription "SUB_ID"
  asc win-back-offers relationships --subscription "SUB_ID" --paginate`,
		FlagSet:   fs,
		UsageFunc: DefaultUsageFunc,
		Exec: func(ctx context.Context, args []string) error {
			if *limit != 0 && (*limit < 1 || *limit > winBackOffersMaxLimit) {
				return fmt.Errorf("win-back-offers relationships: --limit must be between 1 and %d", winBackOffersMaxLimit)
			}
			if err := validateNextURL(*next); err != nil {
				return fmt.Errorf("win-back-offers relationships: %w", err)
			}

			trimmedID := strings.TrimSpace(*subscriptionID)
			if trimmedID == "" && strings.TrimSpace(*next) == "" {
				fmt.Fprintln(os.Stderr, "Error: --subscription is required")
				return flag.ErrHelp
			}

			client, err := getASCClient()
			if err != nil {
				return fmt.Errorf("win-back-offers relationships: %w", err)
			}

			requestCtx, cancel := contextWithTimeout(ctx)
			defer cancel()

			opts := []asc.LinkagesOption{
				asc.WithLinkagesLimit(*limit),
				asc.WithLinkagesNextURL(*next),
			}

			if *paginate {
				paginateOpts := append(opts, asc.WithLinkagesLimit(winBackOffersMaxLimit))
				firstPage, err := client.GetSubscriptionWinBackOffersRelationships(requestCtx, trimmedID, paginateOpts...)
				if err != nil {
					return fmt.Errorf("win-back-offers relationships: failed to fetch: %w", err)
				}

				resp, err := asc.PaginateAll(requestCtx, firstPage, func(ctx context.Context, nextURL string) (asc.PaginatedResponse, error) {
					return client.GetSubscriptionWinBackOffersRelationships(ctx, trimmedID, asc.WithLinkagesNextURL(nextURL))
				})
				if err != nil {
					return fmt.Errorf("win-back-offers relationships: %w", err)
				}

				return printOutput(resp, *output, *pretty)
			}

			resp, err := client.GetSubscriptionWinBackOffersRelationships(requestCtx, trimmedID, opts...)
			if err != nil {
				return fmt.Errorf("win-back-offers relationships: %w", err)
			}

			return printOutput(resp, *output, *pretty)
		},
	}
}

type optionalInt struct {
	set   bool
	value int
}

func (i *optionalInt) Set(value string) error {
	parsed, err := strconv.Atoi(strings.TrimSpace(value))
	if err != nil {
		return fmt.Errorf("must be an integer")
	}
	i.value = parsed
	i.set = true
	return nil
}

func (i *optionalInt) String() string {
	if !i.set {
		return ""
	}
	return strconv.Itoa(i.value)
}

func normalizeWinBackOfferDuration(value string) (asc.SubscriptionOfferDuration, error) {
	normalized := normalizeEnumValue(value)
	if normalized == "" {
		return "", nil
	}
	if duration, ok := winBackOfferDurationMap[normalized]; ok {
		return duration, nil
	}
	return "", fmt.Errorf("--duration must be one of: %s", strings.Join(winBackOfferDurationValues, ", "))
}

func normalizeWinBackOfferMode(value string) (asc.SubscriptionOfferMode, error) {
	normalized := normalizeEnumValue(value)
	if normalized == "" {
		return "", nil
	}
	if mode, ok := winBackOfferModeMap[normalized]; ok {
		return mode, nil
	}
	return "", fmt.Errorf("--offer-mode must be one of: %s", strings.Join(winBackOfferModeValues, ", "))
}

func normalizeWinBackOfferPriority(value string) (asc.WinBackOfferPriority, error) {
	normalized := normalizeEnumValue(value)
	if normalized == "" {
		return "", nil
	}
	if priority, ok := winBackOfferPriorityMap[normalized]; ok {
		return priority, nil
	}
	return "", fmt.Errorf("--priority must be one of: %s", strings.Join(winBackOfferPriorityValues, ", "))
}

func normalizeWinBackOfferPromotionIntent(value string) (asc.WinBackOfferPromotionIntent, error) {
	normalized := normalizeEnumValue(value)
	if normalized == "" {
		return "", nil
	}
	if intent, ok := winBackOfferPromotionIntentMap[normalized]; ok {
		return intent, nil
	}
	return "", fmt.Errorf("--promotion-intent must be one of: %s", strings.Join(winBackOfferPromotionIntentValues, ", "))
}

func normalizeEnumValue(value string) string {
	trimmed := strings.TrimSpace(value)
	if trimmed == "" {
		return ""
	}
	normalized := strings.ToUpper(trimmed)
	normalized = strings.ReplaceAll(normalized, "-", "_")
	normalized = strings.ReplaceAll(normalized, " ", "_")
	return normalized
}
